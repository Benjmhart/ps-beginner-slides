
# Function composition  

`<<<`

If we have a function `f` and another function `g`

AND the output type of `f` matches the input type of `g`, then we can compose them as below

```purescript
f (g x)

f <<< g
```

`<<<` takes to functions and returns a new function with their composition

the resulting function must be _commutative_


*commutative diagram*

---

# Function application

`$`

A function to the left of the operator is applied to the result of the expression on the right.

```purescript
sqrt (add 10.0 (round 15.25)))
```
can be rewritten as
```purescript
sqrt $ add 10.0 $ round 15.25
```


---

# Curry By Default

each function in purescript takes exactly one input argument

rather than taking additional arguments. it is automatically curried and returns a new function which itself takes one argument, and so on until the result is not a function, so

```purescript
addThenSub :: Int -> Int -> Int -> Int
addThenSub x y z = (x + y) - z
```
can become a new function 
```purescript

add5ThenSub = addThenSub 5

subFromSeven = addThenSub 5 2
--or
subFromSeven' = add5ThenSub 2
```

and finally...
```purescript
result = subFromSeven 2
-- or
result' = addThenSub 5 2 2
```

JS equivalents
```javascript
const addThenSub = x => y => z => (x + y) - z

const add5ThenSub = addThenSub(5)

const subFromSeven = addThenSub(5)(2)

const result = addThenSub(5)(2)(2)
```
note the use of `'` in identifiers,  this is completely legal and you will see it a lot. it is commonly pronounced `prime`.

--- 
# Scope: let ...in and where

---

# Equational Reasoning, Everything is an Expression

- Nothing gets mutated silently
- `if true then 1 else 2` evaluates to 1
- `+` is a function, so is `-`

we can directly compose operators as functions because they are just functions.

we can use the Anonymous Argument `_` to acheive this:

```purescript
twoPlusOneMinusOne = (_ - 1) <<< (_ + 1) $ 2
```

While this allows for a huge amount of abstraction, it also allows us to write non-repetitive, type safe code with maximum expressiveness.

In combination with the type checker, we can safely write polymorphic code without fear of exceptions caused by missing object fields, `null`, undefined, `NaN`, and mutation.

---
