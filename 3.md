
---

# The Type Checker

- Purescript is a compiled, Strongly Typed, and Statically Typed language:

In this paradigm, types are powerful enough to be the specification for our program, and often provide tests _for free_. 

Strong : types do not change/coerce at runtime silently

`1 + "1"` is a type error

Statically typed : types are known at _compile time_

A type inference algorithm, in addition to a few explicit type signatures, is used by the compiler to determine whether or not a program is correct.

Type inference means that the type checker is _often_ able to know the type of a variable without an
explicit annotation.  However there are times when you have more information than the compiler, so some occasional type signatures are necessary

Types do not exist at runtime.

We will see the `::` operator which you can read as '<identifier> Has Type <type>'

a given `Type` will generally correspond to some _term-level_ expression which can generally be verified to be of that type.

---

# Primitive Types

These are Javascript types with safe wrappers available in `Prim`, which is secretly imported in every purescript file.

There are additional simple types that come from purescript in the `Prelude`

- Boolean
```purescript
myBool :: Boolean
myBool = true
```

- Int (32bit signed int)

```purescript
myInt :: Int
myInt = 8
```
- Number (64bit float)
```purescript
myNum :: Number
myNum = 8.0
```

- Char 
```purescript
myChar :: Char
myChar = 'a'
```

- String (not a list of Char)
```purescript
myString :: String
myString = "hello"
```

- Array a
```purescript
myIntArray :: Array Int
myIntArray = [1,2,3]
```

- Record
```purescript
myRec :: { field :: String, field2 :: Int }
myRec = {field: myString, field2: myInt }
```

---

# Prelude Types

These types must be explicitly imported with prelude:
`import Prelude`

These do not directly correspond with a javascript type, 

`unit :: Unit`
- this is like true or false but only one value
- used for functions that don't need a return value
- similar to haskell's `()`

`Void`
- used to denote a type that cannot exist, is is unused

`Ordering`
- has three values: `GT`, `LT`, and `EQ`
- used for comparison, drives `<` and `>` machinery

___

# How to Read a Simple Function Type signature

`simpleLT :: Int -> Int -> Boolean`

`->` is the inline operator to construct a function, it's _right associative_ so brcket behaviour goes to the right.

This is equivalent:

`simpleLT :: Int -> (Int -> Boolean)`

---

### Functions can also be arguments

You can use round braces to accept a function argument such as this
```purescript
doesItPass :: (Int -> Boolean) -> Int -> Boolean
doesItPass f i = f i
-- or
doesItPass = $
```

In this situation the braced area appears to the _left_, letting us know that our function takes another function of the type `Int -> Boolean` as an argument.

This is a simple example of taking a function as an argument however there are many more useful examples.

---

# Type variables and Ad-hoc polymorphism

Up until now all of the types we have used have been fully known, This is known as a concrete type such as `String` However, writing all of our code this way will be repetitive.

We can write code that operates on multiple types _polymorphically_
```purescript
doesItPassPoly :: forall a. (a -> Boolean) -> a -> Boolean
doesItPassPoly p x = p x
```

`forall a.` introduces the type variable `a` to the current scope.

Notice that the _argument_ name `x` does not match the name of `a` - they can be named differently, but the type checker knows that `x` should have the type `a` and indeed that `p` takes an argument of type `a`

In this case, we've declared that our function can handle an `a` of ANY type.

This means that we can't actually do much of anything to `a` since we don't know what it is, which is a fairly strong guarantee that we won't do anything misleading with the _term_ corresponding to type `a`

---
